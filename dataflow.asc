
Programming with DataFlow
===========================

'''

In dataflow programming, a program is represented as a graph:

- nodes represent components of the program: widgets...
- edges represent the path of data exchanged by components

A node (component) uses inputs (input properties of the component) to compute
the values of outputs (output properties of the component). Whenever input
values are modified, the component node computes and updates its output
properties.

If the value of the output properties changes as a result of the computation,
the new values are propagated to other nodes of the graph through the edges
that connect the output of the node to the input of other nodes.

Dataflow programming does not generate side effects and is easy to represent
visually.

To simplify algorithm analysis, we introduce a constraint for the dataflow
graph: only
http://en.wikipedia.org/wiki/Directed_acyclic_graph[Directed Acyclic Graphs]
are allowed.

Refer to the end of this specification for a discussion on limitations
related to this constraint and how to mitigate them.

'''


Besoins
=======

Connexion 1 - 1
---------------

Connexion de deux propriétés de deux componsants diférents.

Permet de réaliser la fonction A.p <= B.p +
Lors que B.p change, sa valeur est propagée à A.p.

Connexion n - n
---------------

Connexion de 2n propriétés de deux componsants diférents.

Permet de réaliser la fonction [A.p1, A.p2, ..., A.pn] <= [B.p1, B.p2, ..., B.pn] +
Lors qu'une ou plusieurs propriété(s) [p1, p2, ..., pn] de B change(nt), les valeurs sont propagées à A.

Connexion + fonction de transformation
--------------------------------------

Connexion de propriétés de deux componsants diférents avec une fonction de transformation.

Permet de réaliser la fonction A.p <= f (B.p) +
Lors que B.p change, f (valeur de B.p) est propagée à A.p.

Connexion n - m (demux / mux)
-----------------------------

Connexion de n propriétés d'un componsant A avec m propriétés d'un composants B.

Par exemple:

1. demultiplexer: 1 vers n. Ex: A.p <= f (B.p1, B.p2, ..., B.pn)
2. multiplexer: n vers 1. Ex: [A.p1, A.p2, ..., A.pn] <= f (B.p)
3. generic: n vers m. Ex: [A.p1, A.p2, ..., A.pn] <= f (B.p1, B.p2, ..., B.pm)

Deconnexion
------------
???

API 1
=====

------------
d = new DataFlow ();
d.connect (rect1, "width", rect2, "height", func)
d.connect (rect1, ["width", "height"], rect2, ["height", "width"], func)
------------

Deconnexion ?

API 2
=====

------------
rect1.connect (rect2, "width", "height", func)
rect1.connect (rect2, ["width", "height"], ["height", "width"], func)
------------

Deconnexion ?

API 2 bis
=========

------------
rect1.connect ("width", rect2, "height", func)
rect1.connect (["width", "height"], rect2, ["height", "width"], func)
------------

Deconnexion ?

API 3
=====

------------
d = new DataFlow ();
d.connect (rect1.width, rect2.height, func)
d.connect ([rect1.width, rect1.height], [rect2.height, rect2.width], func)
------------

Deconnexion ?

API 4
=====

API actuelle, pas très 'human readable'.

------------
_df_create (_df_id);
_df_register_node (_df_id, ["id_8","id_10","id_9","id_11"]);
_df_register_edges (_df_id,
  {"id_8": [
    ["id_10",[["posterUrl","poster"],["videoUrl","src"]]],
    ["id_9",[["title","text"]]],
    ["id_11",[["content","text"]]]
  ]});
------------

Deconnexion ?

Construction
------------
var d = new DataFlow ();

Connexion
---------

Connexion 1 - 1
~~~~~~~~~~~~~~~

d.connect (rect1, "width", rect2, "height")
=>
rect2.height <= rect1.width

Connexion n - m
~~~~~~~~~~~~~~~

d.connect (rect1, ["width", "height"], rect2, ["height", "width"])
=>
rect2.height <= rect1.width
rect2.width <= rect1.height

This declaration:
d.connect (rect1, ["width", "height"], rect2, ["height", "width"])
is equivalent to
d.connect (rect1, "width", rect2, "height")
d.connect (rect1, "height", rect2, "width")

Multiplexer
-----------

d.connect (rect1, ['width', 'height'], circle, 'r', surface)

function surface (values)
{
  return Math.sqrt (values[0] * values[1] / Math.PI);
}

Demultiplexer
-------------

d.connect (obj1, out1, obj1, [in1, in2], range)

function range (value)
{
  return [value - 10, value + 10];
}


API (en construction)
---------------------

Exemple d'une possible implementation de l'API 1.

Construction
~~~~~~~~~~~~
var d = new DataFlow ();

Connect 1 - 1
~~~~~~~~~~~~~

---------------------
d.connect (obj /*Object*/, propertyName /*String*/, obj /*Object*/, propertyName /*String*/, func /*Function*/ )
---------------------


Connect n - m
~~~~~~~~~~~~~

---------------------
d.connect (obj /*Object*/, [propertyName, ...] /*Array<String>*/, obj /*Object*/, [propertyName, ...] /*Array<String>*/, func /*Function*/ )
---------------------


Algorithmes
===========


Dataflow structure
------------------

-------------------
function DAG () {
  this._edges_from = {};
  this._list_node = [];
});
-------------------

Sort
----

Compilation et optimisation du graphe.

Use classical sorting algorithm with cycle-detection.
See, e.g., http://www.cs.umb.edu/cs310/class23.html


-------------------
DAG.prototype.sort () {
  /// 1) Calculate in-degrees for nodes
  var nb_node = this._list_node.length;
  var indegrees = [];

  for (var i = 0; i < nb_node; i++)
  {
    indegrees [i] = 0;
  }

  for (var key in this._edges_from)
  {
    /// FIXME: For more efficiency, store indexes into edges to avoid node
    /// search.
    var ids = this._edges_from [key]
    for (var j = 0; j < ids.length; j++)
    {
      //find the index of the node in the node list
      var index = this._list_node.findItem (ids [j][0])
      indegrees [index]++;
    }
  }

  /// 2) Initialization
  var pending = this._list_node.slice ();
  var sorted = [];
  var violationcount = 0;

  /// 3) Loop until everything has been sorted
  while (pending.length != 0)
  {
    /// Extract a node of minimal input degree and append it to list topsorted
    var min_i = this._array_min (indegrees);
    var indegree = indegrees [min_i];
    indegrees.remove (min_i);

    var n_id = pending [min_i];
    pending.remove (min_i);
    if (indegree > 0)
    {
      violationcount++;
    }
    sorted.push (n_id);

    /// 4) Decrement indegrees of nodes m adjacent to n
    /// FIXME: For more efficiency, store adjacent nodes to avoid this search.
    /// Use an adjacency matrix implementation ?
    var ids = this._edges_from [n_id];
    if (ids)
    {
      for (var j = 0; j < ids.length; j++)
      {
        var mi =  pending.findItem (ids [j][0]);
        if (mi != -1) indegrees [mi]--;
      }
    }
  }

  delete (pending);

  /// 5) Update node list & return result
  this._list_node = sorted;
  this.is_sorted = true;
  this.is_cyclic = violationcount > 0;

  if (violationcount > 0)
  {
    var edgecount = this._size (this._edges_from);
    console.log (
      "WARNING: Cycles detected during topological sort."
      + violationcount + " dependencies out of " + edgecount
      + " have been violated.\n");
  }
  return !this.is_cyclic;
}
-------------------


Limitations
===========

Besoin de connections bidirectionnelles
---------------------------------------
Si un composant gère des entrées/sorties, typiquement un Widget de type TextField,
on aimerait bien pouvoir déclarer une connection entre le model et le widget qui soit bidirectionnelle :

- si le modèle change alors la valeur du TextField est mise à jour et inversement
- si l'utilisateur change la valeur du TextField alors le modèle est mise à jour.

Ex:
-------------------
d.connect (model, 'name', textField, 'value');
d.connect (textField, 'value', model, 'name');
-------------------

mais cette déclaration crée un cycle donc elle n'est pas viable

Première solution:

Utilisation d'un événement

-------------------
d.connect (model, 'name', textField, 'value');
textField.bind ('change', function (value) { model.name = value; });
-------------------

Deuxième solution:

Crée un nouveau concept qui n'est pas du dataflow mais compatible

-------------------
d.merge (model, 'name', textField, 'value');
-------------------

Exemple d'implémentation de merge

-------------------

A FINIR

function merge (obj_src, obj_src, obj_trg, p_in) {

  obj_src.onChange (obj_src, function (value) {
    obj_trg [p_in] = value;
  });

  obj_trg.onChange ('p_in', function (value) {
    obj_src [obj_src] = value;
  });

}
-------------------


DataFlow hiérarchique
---------------------

Cycle
-----
Donc un programme complexe, il peut arriver que l'on crée un cycle.

De mon expérience j'ai pu observer deux types de cyle:

1. une boucle de type 'trigger'
2. cycle induit par la hiérarchie de composants

Cycle de type trigger
~~~~~~~~~~~~~~~~~~~~~

Dans le graphe, il a un retour de valeur pour affiner un calcul par exemple.

Exemple de cycle :

-------------------
df.connect (a, 'p_out', b, 'p_in');
df.connect (b, 'p_out', c, 'p_in1');
df.connect (c, 'p_out', d, 'p_in');
df.connect (d, 'p_out', e, 'p_in');
df.connect (d, 'p_out', c, 'p_in2'); // cycle
-------------------

Casser le cycle en rajoutant une temporisation et un système de stabilisation


Exemple de solution :

-------------------
df.connect (a, 'p_out', b, 'p_in');
df.connect (b, 'p_out', c, 'p_in1');
df.connect (c, 'p_out', d, 'p_in');
df.connect (d, 'p_out', e, 'p_in');

d.onChange ('p_out' function (value) {
  setTimeout (function () {
    if (!eq (value, c.p_in2)) // stabilisateur
      c.p_in2 = value; // système non stable => new burst
  }, 0);
})
-------------------

Ce type de solution peut être généree automatiquement

-------------------
df.asyncConnect (d, 'p_out', c, 'p_in2', null, equivalenceFunction)
-------------------

Cycle du à la hierarchie
~~~~~~~~~~~~~~~~~~~~~~~~
A - B


