== Programming with DataFlow ==

In dataflow programming, a program is represented as a graph:

- nodes represent components of the program: widgets...
- edges represent the path of data exchanged by components

A node (component) uses inputs (input properties of the component) to compute
the values of outputs (output properties of the component). Whenever input
values are modified, the component node computes and updates its output
properties.

If the value of the output properties changes as a result of the computation,
the new values are propagated to other nodes of the graph through the edges
that connect the output of the node to the input of other nodes.

Dataflow programming does not generate side effects and is easy to represent
visually.

To simplify algorithm analysis, we introduce a constraint for the dataflow
graph: only
http://en.wikipedia.org/wiki/Directed_acyclic_graph[Directed Acyclic Graphs]
are allowed.

Refer to the end of this specification for a discussion on limitations
related to this constraint and how to mitigate them.

== Use Cases (Requirements) ==

=== 1-1 Relationship ===

A connection from an output property 'out' of a component 'c1'
to an input property 'in' of a different component 'c2'.

Allows to implement the function c2.in <= c1.out +
Whenever 'c1.out' changes, 'c2.in' is updated with the new value.

=== N-N Relationship ===

A connection from several output properties 'out1', 'out2', ... 'outN' of a
component 'c1' to the same number of input properties 'in1', 'in2', ..., 'inN'
of a different component 'c2'.

Allows to implement the function
[c2.in1, c2.in2, ..., c2.inN] <= [c1.out1, c1.out2, ..., c1.outN] +
Whenever the value of any property of component c1 in the list
('out1', 'out2', ..., 'outN') changes, the corresponding property of
component 'c2', at the same position in the list ('in1', 'in2', ..., 'inN')
is updated with the new value.

This N-N relationship is equivalent to the 'N' following 1-1 relationships:

* c2.in1 <= c1.out1
* c2.in2 <= c1.out2
* ...
* c2.inN <= c1.outN

=== 1-1 Relationship with transformation ===

A connection from an output property 'out' of a component 'c1'
to an input property 'in' of a different component 'c2'
with a transformation function 'f' applied to the value.

Allows to implement the function c2.in <= f (c1.out) +
Whenever 'c1.out' changes, 'c2.in' is updated with the result of the
transformation function 'f' applied to the new value.

=== N-M Relationship (mux/demux) ===

A connection from 'N' output properties of a component 'c1'
to 'M' input properties of a different component 'c2'.

==== Example ====

1. multiplexer (mux): c2.in <= mux (c1.out1, c1.out2, ..., c1.outN) +
  1 input property 'in' of component 'c2' is updated with a single value
  produced by the multiplexing function 'mux' applied to the 'N' values of
  output properties 'out1', 'out2', ..., 'outN' of component 'c1'.

2. demultiplexer (demux): [c2.in1, c2.in2, ..., c2.inM] <= demux (c1.out) +
  M input properties 'in1', 'in2', ..., 'inM' of component 'c2' are updated
  with the same number of result values produced by the demultiplexing
  function 'demux' applied to the single value of output property 'out'
  of component 'c1'.

3. N-M relationship with transformation (general case):
  [c2.in1, c2.in2, ..., c2.inM] <= f (c1.out1, c1.out2, ..., c1.outN) +
  Whenever the value of any property of component 'c1' in the list
  ('out1', 'out2', ..., 'outN') changes, all properties of component 'c2' in
  the list ('in1', 'in2', ..., 'inM') are updated with the corresponding
  result value, at the same position in the list of results
  ('result1', 'result2', ..., 'resultM') produced by the transformation
  function 'f' applied to the values of properties 'out1', 'out2', ... 'outN'
  of component 'c1'.

=== Disconnection ===

TO BE COMPLETED

== API 1 ==

-------------------------------------------------------------------------------
var d = new DataFlow ();
d.connect (rect1, "width", rect2, "height", func);
d.connect (rect1, ["width", "height"], rect2, ["height", "width"], func);
-------------------------------------------------------------------------------

This declaration:
-------------------------------------------------------------------------------
d.connect (rect1, ["width", "height"], rect2, ["height", "width"]);
-------------------------------------------------------------------------------
is equivalent to
-------------------------------------------------------------------------------
d.connect (rect1, "width", rect2, "height");
d.connect (rect1, "height", rect2, "width");
-------------------------------------------------------------------------------

=== Disconnection ===

TO BE COMPLETED

== API 2 ==

-------------------------------------------------------------------------------
rect1.connect (rect2, "width", "height", func);
rect1.connect (rect2, ["width", "height"], ["height", "width"], func);
-------------------------------------------------------------------------------

=== Disconnection ===

TO BE COMPLETED

== API 2 bis ==

-------------------------------------------------------------------------------
rect1.connect ("width", rect2, "height", func);
rect1.connect (["width", "height"], rect2, ["height", "width"], func);
-------------------------------------------------------------------------------

=== Disconnection ===

TO BE COMPLETED

== API 3 ==

-------------------------------------------------------------------------------
var d = new DataFlow ();
d.connect (rect1.width, rect2.height, func);
d.connect ([rect1.width, rect1.height], [rect2.height, rect2.width], func);
-------------------------------------------------------------------------------

=== Disconnection ===

TO BE COMPLETED

== API 4 ==

Current API, not very
http://en.wikipedia.org/wiki/Human_readable["human readable"].

-------------------------------------------------------------------------------
_df_create (_df_id);
_df_register_node (_df_id, ["id_8", "id_10", "id_9", "id_11"]);
_df_register_edges (
  _df_id,
  {
    "id_8": [
      [
        "id_10",
        [
          ["posterUrl", "poster"],
          ["videoUrl","src"]
        ]
      ],
      [
        "id_9",
        [
          ["title", "text"]
        ]
      ],
      [
        "id_11",
        [
          ["content", "text"]
        ]
      ]
    ]
  }
);
-------------------------------------------------------------------------------

=== Disconnection ===

TO BE COMPLETED

== Use Cases With API 1 ==

=== Construction ===

-------------------------------------------------------------------------------
var d = new DataFlow ();
-------------------------------------------------------------------------------

=== 1-1 Relationship ===

-------------------------------------------------------------------------------
d.connect (c1, "out", c2, "in");
-------------------------------------------------------------------------------
implements the function: c2.in <= c1.out

=== N-N Relationship ===

-------------------------------------------------------------------------------
d.connect (c1, ["out1", "out2", ..., "outN"], c2, ["in1", "in2", ..., "inN"]);
-------------------------------------------------------------------------------
implements the function:
[c2.in1, c2.in2, ..., c2.inN] <= [c1.out1, c1.out2, ..., c1.outN]

=== N-M Relationship (mux/demux) ===

==== Multiplexer ====

-------------------------------------------------------------------------------
d.connect (c1, ["out1", "out2", ..., "outN"], c2, "in", mux);
-------------------------------------------------------------------------------
implements the function: c2.in <= mux (c1.out1, c1.out2, ..., c1.outN)

===== Example =====

-------------------------------------------------------------------------------
d.connect (rect1, ['width', 'height'], circle, 'r', surface);

function surface (values)
{
  return Math.sqrt (values[0] * values[1] / Math.PI);
}
-------------------------------------------------------------------------------

=== Demultiplexer ===

-------------------------------------------------------------------------------
d.connect (c1, "out", c2, ["in1", "in2", ..., "inM"], demux);
-------------------------------------------------------------------------------
implements the function: [c2.in1, c2.in2, ..., c2.inM] <= demux (c1.out)

==== Example ====

-------------------------------------------------------------------------------
d.connect (obj1, "out1", obj1, ["in1", "in2"], range);

function range (value)
{
  return [value - 10, value + 10];
}
-------------------------------------------------------------------------------


=== API (Work In Progress) ===

This is an example of implementation for the API 1.

==== Construction ====

-------------------------------------------------------------------------------
var d = new DataFlow ();
-------------------------------------------------------------------------------

==== 1-1 Relationship ====

-------------------------------------------------------------------------------
d.connect (
  c1 /*Object*/,
  outputPropertyName /*String*/,
  c2 /*Object*/,
  inputPropertyName /*String*/,
  f /*Function*/
);
-------------------------------------------------------------------------------


==== N-M Relationship ====

-------------------------------------------------------------------------------
d.connect (
  c1 /*Object*/,
  [outputPropertyName1, ..., outputPropertyNameN] /*Array<String>*/,
  c2 /*Object*/,
  [inputPropertyName1, ..., inputPropertyNameM] /*Array<String>*/,
  f /*Function*/
);
-------------------------------------------------------------------------------


== Algorithms ==


=== Dataflow Structure ===

-------------------------------------------------------------------------------
function DAG () {
  this._edges_from = {};
  this._list_node = [];
}
-------------------------------------------------------------------------------

==== Sort ====

Compilation and optimization of the graph.

Use classical sorting algorithm with cycle-detection.
See, e.g., http://www.cs.umb.edu/cs310/class23.html


-------------------------------------------------------------------------------
DAG.prototype.sort = function ()
{
  /// 1) Calculate in-degrees for nodes
  var nb_node = this._list_node.length;
  var indegrees = [];

  for (var i = 0; i < nb_node; i++)
  {
    indegrees [i] = 0;
  }

  for (var key in this._edges_from)
  {
    /// FIXME: For more efficiency, store indexes into edges to avoid node
    /// search.
    var ids = this._edges_from [key];
    for (var j = 0; j < ids.length; j++)
    {
      //find the index of the node in the node list
      var index = this._list_node.findItem (ids [j][0]);
      indegrees [index]++;
    }
  }

  /// 2) Initialization
  var pending = this._list_node.slice ();
  var sorted = [];
  var violationcount = 0;

  /// 3) Loop until everything has been sorted
  while (pending.length != 0)
  {
    /// Extract a node of minimal input degree and append it to list topsorted
    var min_i = this._array_min (indegrees);
    var indegree = indegrees [min_i];
    indegrees.remove (min_i);

    var n_id = pending [min_i];
    pending.remove (min_i);
    if (indegree > 0)
    {
      violationcount++;
    }
    sorted.push (n_id);

    /// 4) Decrement indegrees of nodes m adjacent to n
    /// FIXME: For more efficiency, store adjacent nodes to avoid this search.
    /// Use an adjacency matrix implementation ?
    var ids = this._edges_from [n_id];
    if (ids)
    {
      for (var j = 0; j < ids.length; j++)
      {
        var mi =  pending.findItem (ids [j][0]);
        if (mi != -1) indegrees [mi]--;
      }
    }
  }

  delete (pending);

  /// 5) Update node list & return result
  this._list_node = sorted;
  this.is_sorted = true;
  this.is_cyclic = violationcount > 0;

  if (violationcount > 0)
  {
    var edgecount = this._size (this._edges_from);
    console.log (
      "WARNING: Cycles detected during topological sort."
      + violationcount + " dependencies out of " + edgecount
      + " have been violated.\n"
    );
  }
  return !this.is_cyclic;
};
-------------------------------------------------------------------------------


== Limitations ==

=== Besoin de connections bidirectionnelles ===

Si un composant gère des entrées/sorties, typiquement un Widget de type TextField,
on aimerait bien pouvoir déclarer une connection entre le model et le widget qui soit bidirectionnelle :

- si le modèle change alors la valeur du TextField est mise à jour et inversement
- si l'utilisateur change la valeur du TextField alors le modèle est mise à jour.

Ex:
-------------------------------------------------------------------------------
d.connect (model, 'name', textField, 'value');
d.connect (textField, 'value', model, 'name');
-------------------------------------------------------------------------------

mais cette déclaration crée un cycle donc elle n'est pas viable

Première solution:

Utilisation d'un événement

-------------------------------------------------------------------------------
d.connect (model, 'name', textField, 'value');
textField.bind ('change', function (value) {
  model.name = value;
});
-------------------------------------------------------------------------------

Deuxième solution:

Crée un nouveau concept qui n'est pas du dataflow mais compatible

-------------------------------------------------------------------------------
d.merge (model, 'name', textField, 'value');
-------------------------------------------------------------------------------

Exemple d'implémentation de merge

-------------------------------------------------------------------------------

TO BE COMPLETED

function merge (obj_src, obj_src, obj_trg, p_in)
{

  obj_src.onChange (obj_src, function (value) {
    obj_trg [p_in] = value;
  });

  obj_trg.onChange ('p_in', function (value) {
    obj_src [obj_src] = value;
  });

}
-------------------------------------------------------------------------------


=== DataFlow hiérarchique ===

=== Cycle ===

Donc un programme complexe, il peut arriver que l'on crée un cycle.

De mon expérience j'ai pu observer deux types de cyle:

1. une boucle de type 'trigger'
2. cycle induit par la hiérarchie de composants

==== Cycle de type trigger ====

Dans le graphe, il a un retour de valeur pour affiner un calcul par exemple.

Exemple de cycle :

-------------------------------------------------------------------------------
df.connect (a, 'p_out', b, 'p_in');
df.connect (b, 'p_out', c, 'p_in1');
df.connect (c, 'p_out', d, 'p_in');
df.connect (d, 'p_out', e, 'p_in');
df.connect (d, 'p_out', c, 'p_in2'); // cycle
-------------------------------------------------------------------------------

Casser le cycle en rajoutant une temporisation et un système de stabilisation


Exemple de solution :

-------------------------------------------------------------------------------
df.connect (a, 'p_out', b, 'p_in');
df.connect (b, 'p_out', c, 'p_in1');
df.connect (c, 'p_out', d, 'p_in');
df.connect (d, 'p_out', e, 'p_in');

d.onChange ('p_out', function (value) {
  setTimeout (function () {
    if (!eq (value, c.p_in2)) // stabilisateur
      c.p_in2 = value; // système non stable => new burst
  }, 0);
})
-------------------------------------------------------------------------------

Ce type de solution peut être généree automatiquement

-------------------------------------------------------------------------------
df.asyncConnect (d, 'p_out', c, 'p_in2', null, equivalenceFunction);
-------------------------------------------------------------------------------

==== Cycle du à la hierarchie ====
A - B


